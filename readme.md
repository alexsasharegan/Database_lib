# Database
[![Latest Stable Version](https://poser.pugx.org/alexsasharegan/database/v/stable)](https://packagist.org/packages/alexsasharegan/database)
[![Total Downloads](https://poser.pugx.org/alexsasharegan/database/downloads)](https://packagist.org/packages/alexsasharegan/database)
[![Latest Unstable Version](https://poser.pugx.org/alexsasharegan/database/v/unstable)](https://packagist.org/packages/alexsasharegan/database)
[![License](https://poser.pugx.org/alexsasharegan/database/license)](https://packagist.org/packages/alexsasharegan/database)

PHP Mysqli utilities to properly handle errors, connections, and make getting data simple and DRY.

- - - -


## Installation

If you're using **Composer**:

```shell
$ composer require alexsasharegan/database
```

Then require in the vendor autoloader:
```php
<?php

require_once 'path/to/vendor/autoload.php';
```

To install from **github**:

```shell
$ git clone https://github.com/alexsasharegan/Database_lib.git
```

Then require in the autoloader:

```php
<?php

require_once 'path/to/Database_lib/Database_Autoloader.php';
```

## Documentation

To start, you'll need to have node.js installed, and php >=5.4. From the command line, run the following:
  
```shell
npm start
```

This will fire up the doc server at [localhost:4444](http://localhost:4444).

Docs generated by [Sami](https://github.com/FriendsOfPHP/Sami).

## Usage

- - - -

### Static Methods

Calling `Database::connect( [ string $configFile = './database.json', array $options = [] ] )` without any arguments will look for a configuration file called `database.json` file in the calling file's directory. To make use of this default behavior, place your `database.json` next to your php file. If your config file exists elsewhere, pass in the path as the first argument.

An example config file is included in the project. Just change the name from `database.example.json` to `database.json` and move it next to your calling php file. Here is the example config:

```json
{
  "host"     : "yourHostName",
  "database" : "yourDatabaseName",
  "username" : "yourUsername",
  "password" : "yourPassword"
}
```

If you wish to connect using different connection settings on the fly, as the second argument you can pass an associative array with whichever connection setting you wish to override. The config array contains the same keys as `database.json`:

```php
<?php

require_once 'path/to/Database_Autoloader.php';

use Database\MySQL;

# Pass in an associative array like this
# with any number of these four params
# that you wish to override

$CONFIG_OPTIONS = [
  'host'     => 'yourHostName',
  'database' => 'yourDatabaseName',
  'username' => 'yourUsername',
  'password' => 'yourpassword',
];

$mysqliHandle = MySQL::connect('path/to/database.json', $CONFIG_OPTIONS);

# if you're overriding all config options, you don't need the config file
# just pass null as the first argument
$mysqliHandle = MySQL::connect(null, $CONFIG_OPTIONS);

# if you want to save configurations for different databases,
# just use the json config format from database.json
# and name it however you like. Here is a suggested convention:
$mysqliHandleToUsers     = MySQL::connect('users.database.json');
$mysqliHandleToEmployees = MySQL::connect('employees.database.json');
```

Some other static methods:

```php
<?php

use Database\MySQL;

# Takes a MySQL-formatted date string and returns a string file path
MySQL::SQLDateToPath( string $SQLDate, string $timezone = "America/Phoenix" )
# example
echo MySQL::SQLDateToPath( '2016-09-06 14:02:26' );
# Outputs: '2016/09/06'

# Returns a MySQL-formatted timestamp
MySQL::now( string $timezone = "America/Phoenix" )
# example
echo MySQL::now();
# Outputs: '2016-09-06 14:04:15';

echo MySQL::randomString(8);
# Outputs: 'vayxwhrt';
```

### Instance Methods

#### QUERY

```php
<?php

# Alias the MySQL class
use Database\MySQL;

# create an instance with these credentials
# opens a MySQL connection and saves the handle internally
$db = new MySQL(null, [
  'host'     => '1.1.1.1',
  'database' => 'myDatabase',
  'username' => 'admin',
  'password' => 'adminPass',
]);

# create an empty user to save our query result
$users = [];

# use a try/catch block to handle a bad query
try {
  $db->query( "SELECT * FROM `users`" )
    # we can chain methods together here
    ->iterateResult(
      # this can be any callable type ( will be called with each row )
      # closures let us 'use' vars from parent scope
      # be wary of when you need to pass by reference using &
      function ( array $resultRow ) use ( &$user ) {
        $users[] = $resultRow; # the $resultRow is an associative array
      }
    );
} catch ( Exception $e ) {
  # insert some custom error handling here
  exit( $e );
}
```

#### SELECT

```php
<?php

$db->select('users');
// SELECT * FROM `users`

$db->select('users', ['*'], [
	'AND' => [
		'group' => 'employees',
		'status[!=]' => 'TERMINATED',
		'conversions[>]' => 50,
	]
]);
// SELECT * FROM `users` WHERE (`group`='employees') AND (`status`!='TERMINATED') AND (`conversions`>50)
```

#### INSERT

```php
<?php
require_once 'path/to/vendor/autoload.php';
use Database\MySQL;

$db = new MySQL('./path/to/database.json');

# some data for our new user
$newUser = [
  'firstName' => 'John',
  'lastName'  => 'Doe',
  'status'    => 'NEW',
  'created'   => MySQL::getSQLDate(),
];

# returns the insert id on success, FALSE on failure
$userId = $db->insert('users', $newUser);

# alternately, we can turn on ON DUPLICATE UPDATE
# with all the same insert values by passing TRUE
$userId = $db->insert('users', $newUser, TRUE);

# if you need to define a custom set of update key/value pairs,
# use Database\MySQL::insertOnDuplicate
$userId = $db->insertOnDuplicate('users', $newUser, ['status' => 'MODIFIED']);
# this will only update the status to 'MODIFIED' on duplicate
```

#### Other Methods

```php
<?php
require_once 'path/to/vendor/autoload.php';
use Database\MySQL;

$db = new MySQL;

$db->query("SELECT * FROM `users`");
# chainable method returns object instance

$db->iterateResult(function ($row) {
  # do stuff to row ...
});
# chainable method returns object instance

$mappedResult = $db->mapResult(function ($row) {
  return $row;
});
# applies the callback to each row of the mysqli result  
# and returns an indexed array with the new values

$reducedResult = $db->reduceResult(function ($carry, $row) {
	return $carry . '<li>' . $row['first_name'] . ' ' . $row['last_name'] . '</li>'; 
}, '');
# applies the callback against the accumulator ($carry) and each row of the mysqli result
# reducing them down to a single value

$db->getLastQuery();
# returns "SELECT * FROM `users`"

$db->getLogs();
# returns an array of all executed queries

$db->getResult();
# returns the mysqli result object from the last query or NULL

$db->getError();
# returns the last error message for the most recent MySQLi function call that can succeed or fail

$db->affectRows();
# returns the number of affected rows from the last query (UPDATE, DELETE)

$db->numRows();
# if a successful mysqli result object was returned, gets the number of rows in the result set 

$db->id();
# returns the insert id from the last query or NULL

$db->escape( $stringToEscape );
# returns the escaped string

# the connection handle is stored here:
Database\MySQL::db
# you can use all the mysqli methods from this prop

```
